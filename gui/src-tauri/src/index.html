<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lysande Linjetrafik</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f5;
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .subtitle {
            opacity: 0.9;
            font-size: 1rem;
        }

        .portable-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 0.8rem;
            margin-top: 8px;
        }

        .config-panel {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            cursor: pointer;
        }

        .config-header h3 {
            margin: 0;
            color: #555;
        }

        .config-toggle {
            color: #667eea;
            font-size: 0.9rem;
        }

        .config-content {
            display: none;
        }

        .config-content.visible {
            display: block;
        }

        .data-path-section {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .current-path {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.85rem;
            color: #666;
            background: #e9ecef;
            padding: 8px 12px;
            border-radius: 4px;
            margin: 8px 0;
            word-break: break-all;
        }

        .path-status {
            font-size: 0.85rem;
            margin-top: 8px;
            padding: 8px 12px;
            border-radius: 4px;
        }

        .path-status.exists {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .path-status.missing {
            background: #ffebee;
            color: #c62828;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #555;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.2s;
            font-family: 'SF Mono', Monaco, monospace;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-hint {
            font-size: 0.8rem;
            color: #888;
            margin-top: 4px;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #555;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .search-panel {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .autocomplete-item:hover {
            background: #f5f5f5;
        }

        .autocomplete-item .name {
            font-weight: 500;
        }

        .autocomplete-item .details {
            font-size: 0.85rem;
            color: #666;
            margin-top: 2px;
        }

        .find-routes-btn {
            width: 100%;
            padding: 14px 32px;
        }

        .results-panel {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }

        .results-panel.visible {
            display: block;
        }

        .route-card {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .route-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .route-duration {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
        }

        .route-transfers {
            font-size: 0.9rem;
            color: #666;
        }

        .leg-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .leg-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }

        .leg-mode {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.75rem;
            padding: 4px 8px;
            background: #667eea;
            color: white;
            border-radius: 4px;
            margin-right: 12px;
        }

        .leg-details {
            flex: 1;
        }

        .leg-stations {
            font-weight: 500;
        }

        .leg-info {
            font-size: 0.85rem;
            color: #666;
            margin-top: 2px;
        }

        #map {
            height: 400px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1;
        }
        
        .leaflet-popup-content {
            margin: 8px 12px;
            font-size: 14px;
        }
        
        .route-polyline {
            stroke-dasharray: 10, 10;
            animation: dash 30s linear infinite;
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: -1000;
            }
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .success {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .info {
            background: #e3f2fd;
            color: #1565c0;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        /* Debug panel */
        #debug-log {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #1a1a1a;
            color: #00ff00;
            padding: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            z-index: 99999;
            max-height: 200px;
            overflow: auto;
            border-top: 2px solid #333;
        }
        
        #debug-log .error {
            color: #ff4444;
            background: transparent;
            padding: 0;
            margin: 0;
        }
        
        #debug-log .warn {
            color: #ffaa00;
        }
        
        #debug-log .info {
            color: #00aaff;
            background: transparent;
            padding: 0;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üöå Lysande Linjetrafik</h1>
            <p class="subtitle">Plan your journey with real-time public transit data</p>
            <div class="portable-badge">üíæ Portable Edition ‚Äî Runs from USB</div>
        </header>

        <div id="map"></div>

        <!-- Data Path Configuration (Portable) -->
        <div class="config-panel">
            <div class="config-header" id="config-toggle">
                <h3>‚öôÔ∏è Data Path Configuration</h3>
                <span class="config-toggle">Show/Hide</span>
            </div>
            <div class="config-content" id="config-content">
                <div class="data-path-section">
                    <label>Current Data Path:</label>
                    <div class="current-path" id="current-path">Not initialized</div>
                    <div class="path-status missing" id="path-status">
                        ‚ö†Ô∏è No data path configured. Please set the path to your MOTIS data directory.
                    </div>

                    <div class="input-group" style="margin-top: 16px;">
                        <label for="data-path-input">Data Directory Path</label>
                        <input type="text" id="data-path-input" placeholder="./data or /path/to/motis/data" 
                               value="./data">
                        <div class="input-hint">
                            ‚Ä¢ Relative paths are resolved from the executable location<br>
                            ‚Ä¢ Default: <code>./data</code> next to the executable<br>
                            ‚Ä¢ USB-friendly: Place your data folder next to the app
                        </div>
                    </div>

                    <div class="btn-group">
                        <button class="btn btn-secondary" id="use-default-btn">Use Default (./data)</button>
                        <button class="btn btn-primary" id="apply-path-btn">Apply & Initialize</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="search-panel">
            <div id="status-message"></div>
            
            <div class="input-group">
                <label for="origin-input">From</label>
                <input type="text" id="origin-input" placeholder="Enter origin (e.g., 'Central Station')" autocomplete="off">
                <div class="autocomplete-dropdown" id="origin-dropdown"></div>
            </div>

            <div class="input-group">
                <label for="destination-input">To</label>
                <input type="text" id="destination-input" placeholder="Enter destination (e.g., 'Airport')" autocomplete="off">
                <div class="autocomplete-dropdown" id="destination-dropdown"></div>
            </div>

            <button class="btn btn-primary find-routes-btn" id="find-routes-btn" disabled>Find Routes</button>
        </div>

        <div class="results-panel" id="results-panel">
            <h2 style="margin-bottom: 16px;">Route Options</h2>
            <div id="routes-container"></div>
        </div>
    </div>

    <!-- Debug log panel (hidden by default, shown when needed) -->
    <div id="debug-log" style="display: none;"></div>

    <script>
        // ============================================
        // TAURI API INITIALIZATION - FIXED VERSION
        // ============================================
        
        // DO NOT set window.__TAURI__ here - Tauri injects it automatically!
        // The polyfill was overwriting Tauri's injected object.
        
        // Global state
        let invoke = null;
        let tauriAvailable = false;
        let originLocation = null;
        let destinationLocation = null;
        let appInitialized = false;
        let currentDataPath = null;
        let debugMode = false;
        let map = null;
        let routeLayers = [];

        // Debug logger - only shows UI in debug mode, always logs to console
        function debug(msg, type = 'log') {
            const timestamp = new Date().toLocaleTimeString();
            const formatted = `[${timestamp}] ${msg}`;
            console.log('[MOTIS]', formatted);
            
            // Only show debug panel if debug mode is enabled
            if (!debugMode) return;
            
            let log = document.getElementById('debug-log');
            if (!log) {
                log = document.createElement('div');
                log.id = 'debug-log';
                document.body.appendChild(log);
            }
            log.style.display = 'block';
            
            const entry = document.createElement('div');
            entry.className = type;
            entry.textContent = formatted;
            log.appendChild(entry);
            
            // Auto-scroll to bottom
            log.scrollTop = log.scrollHeight;
        }

        // Initialize Tauri API
        async function initTauri() {
            debug('Initializing Tauri API...', 'info');
            
            // Wait for Tauri to inject its APIs
            let attempts = 0;
            const maxAttempts = 200; // 10 seconds (50ms * 200)
            
            while (attempts < maxAttempts) {
                // Check for Tauri v2 API structure
                if (window.__TAURI__ && window.__TAURI__.core && typeof window.__TAURI__.core.invoke === 'function') {
                    invoke = window.__TAURI__.core.invoke;
                    tauriAvailable = true;
                    debug('‚úì Tauri v2 API found at __TAURI__.core.invoke', 'info');
                    return true;
                }
                
                // Check for alternative locations
                if (window.__TAURI__ && typeof window.__TAURI__.invoke === 'function') {
                    invoke = window.__TAURI__.invoke;
                    tauriAvailable = true;
                    debug('‚úì Tauri v1 API found at __TAURI__.invoke', 'info');
                    return true;
                }
                
                // Check for internals (Tauri v2 development mode)
                if (window.__TAURI_INTERNALS__ && typeof window.__TAURI_INTERNALS__.invoke === 'function') {
                    invoke = window.__TAURI_INTERNALS__.invoke;
                    tauriAvailable = true;
                    debug('‚úì Tauri internals found', 'info');
                    return true;
                }
                
                attempts++;
                await new Promise(r => setTimeout(r, 50));
            }
            
            // Failed to find Tauri
            debug('‚úó Tauri API not found after ' + maxAttempts + ' attempts', 'error');
            
            if (window.__TAURI__) {
                debug('__TAURI__ object exists with keys: ' + Object.keys(window.__TAURI__).join(', '), 'warn');
            } else {
                debug('__TAURI__ object does not exist', 'error');
            }
            
            // Create a mock invoke for debugging
            invoke = async (cmd, args) => {
                debug(`Mock invoke called: ${cmd}`, 'warn');
                throw new Error('Tauri not available - cannot execute: ' + cmd);
            };
            
            return false;
        }

        // DOM Elements
        const configToggle = document.getElementById('config-toggle');
        const configContent = document.getElementById('config-content');
        const currentPathEl = document.getElementById('current-path');
        const pathStatusEl = document.getElementById('path-status');
        const dataPathInput = document.getElementById('data-path-input');
        const useDefaultBtn = document.getElementById('use-default-btn');
        const applyPathBtn = document.getElementById('apply-path-btn');
        const originInput = document.getElementById('origin-input');
        const destinationInput = document.getElementById('destination-input');
        const originDropdown = document.getElementById('origin-dropdown');
        const destinationDropdown = document.getElementById('destination-dropdown');
        const findRoutesBtn = document.getElementById('find-routes-btn');
        const resultsPanel = document.getElementById('results-panel');
        const routesContainer = document.getElementById('routes-container');
        const statusMessage = document.getElementById('status-message');

        // Toggle config panel
        configToggle.addEventListener('click', () => {
            configContent.classList.toggle('visible');
        });

        // Show status message
        function showStatus(message, type, duration = 3000) {
            statusMessage.innerHTML = `<div class="${type}">${message}</div>`;
            if (duration > 0) {
                setTimeout(() => statusMessage.innerHTML = '', duration);
            }
        }

        // Update path display
        function updatePathDisplay(path, exists) {
            currentPathEl.textContent = path || 'Not set';
            currentDataPath = path;
            
            if (exists) {
                pathStatusEl.className = 'path-status exists';
                pathStatusEl.innerHTML = `‚úì Data directory found at: ${escapeHtml(path)}`;
            } else {
                pathStatusEl.className = 'path-status missing';
                pathStatusEl.innerHTML = `‚úó Data directory not found: ${escapeHtml(path)}`;
            }
        }

        // Initialize app with data path
        async function initWithPath(dataPath) {
            if (!tauriAvailable) {
                showStatus('Tauri not available. Cannot initialize.', 'error', 0);
                debug('initWithPath called but Tauri not available', 'error');
                return false;
            }
            
            applyPathBtn.disabled = true;
            applyPathBtn.textContent = 'Initializing...';
            
            try {
                debug(`Calling init_native with dataPath: ${dataPath}`, 'info');
                const resolvedPath = await invoke('init_native', { dataPath });
                appInitialized = true;
                currentDataPath = resolvedPath;
                updatePathDisplay(resolvedPath, true);
                showStatus(`‚úì Connected to MOTIS backend at ${resolvedPath}`, 'success');
                findRoutesBtn.disabled = false;
                debug('Initialization successful', 'info');
                return true;
            } catch (error) {
                console.error('Failed to initialize:', error);
                debug('Initialization failed: ' + error, 'error');
                appInitialized = false;
                findRoutesBtn.disabled = true;
                updatePathDisplay(dataPath || './data', false);
                showStatus(`‚úó Failed to initialize: ${error}`, 'error', 0);
                return false;
            } finally {
                applyPathBtn.disabled = false;
                applyPathBtn.textContent = 'Apply & Initialize';
            }
        }

        // Check if path exists without initializing
        async function checkPath(path) {
            if (!tauriAvailable) return false;
            
            try {
                return await invoke('check_data_path_exists', { path });
            } catch (e) {
                return false;
            }
        }

        // Get default data path
        async function loadDefaultPath() {
            debug('Loading default path...', 'info');
            
            if (!tauriAvailable) {
                debug('Tauri not available, showing manual config', 'warn');
                updatePathDisplay('./data', false);
                configContent.classList.add('visible');
                showStatus('Native backend not available. Please check debug log.', 'info', 0);
                return;
            }
            
            try {
                const defaultPath = "./data";
                dataPathInput.value = './data';
                
                // Check if default path exists
                debug('Checking if default path exists...', 'info');
                const exists = await checkPath(defaultPath);
                debug(`Default path exists: ${exists}`, 'info');
                
                if (exists) {
                    await initWithPath(null); // null uses default
                } else {
                    updatePathDisplay(defaultPath, false);
                    configContent.classList.add('visible');
                    showStatus('Default data path not found. Please configure the data directory.', 'info', 0);
                }
            } catch (error) {
                console.error('Failed to get default path:', error);
                debug('Error loading default path: ' + error, 'error');
                configContent.classList.add('visible');
            }
        }

        // Use default button
        useDefaultBtn.addEventListener('click', async () => {
            dataPathInput.value = './data';
            await initWithPath(null);
        });

        // Apply path button
        applyPathBtn.addEventListener('click', async () => {
            const path = dataPathInput.value.trim();
            if (!path) {
                showStatus('Please enter a data path', 'error');
                return;
            }
            await initWithPath(path);
        });

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Geocode autocomplete
        async function geocode(query, dropdown, isOrigin) {
            if (!tauriAvailable || !query || query.length < 2) {
                dropdown.style.display = 'none';
                return;
            }

            try {
                const locations = await invoke('geocode_cmd', { query });
                
                dropdown.innerHTML = '';
                if (locations.length === 0) {
                    dropdown.style.display = 'none';
                    return;
                }

                locations.forEach(loc => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.innerHTML = `
                        <div class="name">${escapeHtml(loc.name)}</div>
                        <div class="details">${loc.type || 'Location'} ‚Ä¢ ${loc.lat.toFixed(4)}, ${loc.lon.toFixed(4)}</div>
                    `;
                    item.addEventListener('click', () => {
                        if (isOrigin) {
                            originInput.value = loc.name;
                            originLocation = loc;
                        } else {
                            destinationInput.value = loc.name;
                            destinationLocation = loc;
                        }
                        dropdown.style.display = 'none';
                        updateButtonState();
                    });
                    dropdown.appendChild(item);
                });

                dropdown.style.display = 'block';
            } catch (error) {
                console.error('Geocoding error:', error);
                debug('Geocoding error: ' + error, 'error');
            }
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Update button state
        function updateButtonState() {
            findRoutesBtn.disabled = !(originLocation && destinationLocation && appInitialized);
        }

        // Debounced geocode handlers
        const debouncedGeocodeOrigin = debounce((q) => geocode(q, originDropdown, true), 300);
        const debouncedGeocodeDest = debounce((q) => geocode(q, destinationDropdown, false), 300);

        // Event listeners
        originInput.addEventListener('input', (e) => {
            originLocation = null;
            updateButtonState();
            debouncedGeocodeOrigin(e.target.value);
        });

        destinationInput.addEventListener('input', (e) => {
            destinationLocation = null;
            updateButtonState();
            debouncedGeocodeDest(e.target.value);
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!originInput.contains(e.target) && !originDropdown.contains(e.target)) {
                originDropdown.style.display = 'none';
            }
            if (!destinationInput.contains(e.target) && !destinationDropdown.contains(e.target)) {
                destinationDropdown.style.display = 'none';
            }
        });

        // Find routes
        findRoutesBtn.addEventListener('click', async () => {
            if (!originLocation || !destinationLocation) return;

            findRoutesBtn.disabled = true;
            findRoutesBtn.textContent = 'Finding routes...';
            resultsPanel.classList.remove('visible');

            try {
                const routes = await invoke('plan_route_cmd', {
                    fromLat: originLocation.lat,
                    fromLon: originLocation.lon,
                    toLat: destinationLocation.lat,
                    toLon: destinationLocation.lon
                });

                displayRoutes(routes);
            } catch (error) {
                console.error('Route planning error:', error);
                showStatus('Failed to find routes: ' + error, 'error', 0);
            } finally {
                findRoutesBtn.disabled = false;
                findRoutesBtn.textContent = 'Find Routes';
            }
        });

        // Format duration
        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            }
            return `${minutes} min`;
        }

        // Display routes
        function displayRoutes(routes) {
            routesContainer.innerHTML = '';
            
            // Clear previous route layers from map
            clearRouteLayers();

            if (routes.length === 0) {
                routesContainer.innerHTML = '<p>No routes found.</p>';
                resultsPanel.classList.add('visible');
                return;
            }

            routes.forEach((route, index) => {
                // Display route on map
                displayRouteOnMap(route, index, routes.length);
                const card = document.createElement('div');
                card.className = 'route-card';
                
                let legsHtml = '';
                route.legs.forEach(leg => {
                    const modeIcon = getModeIcon(leg.mode);
                    legsHtml += `
                        <div class="leg-item">
                            <span class="leg-mode">${modeIcon} ${leg.mode}</span>
                            <div class="leg-details">
                                <div class="leg-stations">${escapeHtml(leg.from_name)} ‚Üí ${escapeHtml(leg.to_name)}</div>
                                <div class="leg-info">
                                    ${formatDuration(leg.duration_seconds)} ‚Ä¢ ${leg.distance_meters}m
                                    ${leg.route_short_name ? `‚Ä¢ Line ${escapeHtml(leg.route_short_name)}` : ''}
                                    ${leg.headsign ? `‚Üí ${escapeHtml(leg.headsign)}` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                });

                card.innerHTML = `
                    <div class="route-header">
                        <div>
                            <div class="route-duration">${formatDuration(route.duration_seconds)}</div>
                            <div class="route-transfers">${route.transfers} transfer${route.transfers !== 1 ? 's' : ''}</div>
                        </div>
                        <span style="color: #666;">Option ${index + 1}</span>
                    </div>
                    <div class="leg-list">
                        ${legsHtml}
                    </div>
                `;

                routesContainer.appendChild(card);
            });

            resultsPanel.classList.add('visible');
        }

        // Get mode icon
        function getModeIcon(mode) {
            const icons = {
                'WALK': 'üö∂',
                'BUS': 'üöå',
                'TRAM': 'üöä',
                'RAIL': 'üöÜ',
                'SUBWAY': 'üöá',
                'FERRY': '‚õ¥Ô∏è',
                'AIRPLANE': '‚úàÔ∏è',
                'TAXI': 'üöï',
                'BIKE': 'üö≤',
                'CAR': 'üöó',
            };
            return icons[mode.toUpperCase()] || 'üö∂';
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        
        // Initialize map
        function initMap() {
            if (map) return;
            
            // Default to Stockholm area
            map = L.map('map').setView([59.3293, 18.0686], 12);
            
            // Add OpenStreetMap tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);
            
            debug('Map initialized', 'info');
        }
        
        // Clear route layers from map
        function clearRouteLayers() {
            routeLayers.forEach(layer => map.removeLayer(layer));
            routeLayers = [];
        }
        
        // Display route on map
        function displayRouteOnMap(route, index, total) {
            if (!map) return;
            
            const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe'];
            const color = colors[index % colors.length];
            const opacity = index === 0 ? 0.8 : 0.4;
            
            // Create polyline points from route legs
            const points = [];
            route.legs.forEach(leg => {
                points.push([leg.from.lat, leg.from.lon]);
                points.push([leg.to.lat, leg.to.lon]);
            });
            
            if (points.length > 0) {
                // Draw route line
                const polyline = L.polyline(points, {
                    color: color,
                    weight: index === 0 ? 5 : 3,
                    opacity: opacity,
                    lineJoin: 'round'
                }).addTo(map);
                routeLayers.push(polyline);
                
                // Add markers for start and end
                if (index === 0) {
                    const start = points[0];
                    const end = points[points.length - 1];
                    
                    const startMarker = L.marker(start)
                        .bindPopup('Start: ' + route.legs[0].from_name)
                        .addTo(map);
                    routeLayers.push(startMarker);
                    
                    const endMarker = L.marker(end)
                        .bindPopup('End: ' + route.legs[route.legs.length - 1].to_name)
                        .addTo(map);
                    routeLayers.push(endMarker);
                    
                    // Fit map to show the route
                    map.fitBounds(polyline.getBounds(), { padding: [50, 50] });
                }
            }
        }
        
        // Wait for DOM then initialize Tauri
        document.addEventListener('DOMContentLoaded', async function() {
            debug('DOM loaded, initializing...', 'info');
            
            // Initialize map first
            initMap();
            
            // Initialize Tauri API
            const tauriReady = await initTauri();
            
            if (tauriReady) {
                // Check if debug mode is enabled
                try {
                    debugMode = await invoke('is_debug_mode');
                    if (debugMode) {
                        debug('Debug mode enabled', 'info');
                    }
                } catch (e) {
                    debug('Failed to check debug mode: ' + e, 'error');
                }
                
                debug('Tauri ready, loading default path...', 'info');
                await loadDefaultPath();
            } else {
                debug('Tauri not available - GUI will be limited', 'error');
                showStatus('Tauri backend not available. Check debug log for details.', 'error', 0);
                configContent.classList.add('visible');
            }
        });
    </script>
</body>
</html>
